
<!-- saved from url=(0091)http://pdf7.tarena.com.cn/tts8_source/ttsPage/JAVA/JSD_V05/OOP/DAY04/SUPERDOC/01/index.html -->
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <title>SUPERDOC</title>
    
    <script type="text/javascript" src="./SUPERDOC_files/jquery.min.js">
    </script>
    <script type="text/javascript" src="./SUPERDOC_files/jquery.snippet.js">
    </script>
    <script type="text/javascript" src="./SUPERDOC_files/main.js">
    </script>
    <link type="text/css" href="./SUPERDOC_files/index.css" rel="Stylesheet">
    <link type="text/css" href="./SUPERDOC_files/jquery.snippet.css" rel="Stylesheet">
  </head><style type="text/css" id="9747212574"></style>
  <body>
    <div class="source_style_superdoc">
      <a name="page_top_superdoc" id="top_anchor">
      </a><a id="link_top" href="http://pdf7.tarena.com.cn/tts8_source/ttsPage/JAVA/JSD_V05/OOP/DAY04/SUPERDOC/01/index.html#page_top_superdoc">Top</a>
      <a name="Key01">
      </a>
      <ol class="index">
        <li>
          <a href="http://pdf7.tarena.com.cn/tts8_source/ttsPage/JAVA/JSD_V05/OOP/DAY04/SUPERDOC/01/index.html#Key01">继承的意义（下）</a>
        </li>
        <li>
          <a href="http://pdf7.tarena.com.cn/tts8_source/ttsPage/JAVA/JSD_V05/OOP/DAY04/SUPERDOC/01/index.html#Key02">访问控制</a>
        </li>
        <li>
          <a href="http://pdf7.tarena.com.cn/tts8_source/ttsPage/JAVA/JSD_V05/OOP/DAY04/SUPERDOC/01/index.html#Key03">static和final</a>
        </li>
      </ol>
      <h1>1. 继承的意义（下）</h1>
      <a name="Key01_01">
      </a>
      <h2>1.1. 重写</h2>
      <a name="Key01_01_01">
      </a>
      <h3>1.1.1. 方法的重写</h3>
      <p>下面在昨天的基础之上来增加需求，在输出图形之前先打印格子坐标，即调用print()方法。想实现这个需求做法很简单，只需要父类型引用直接调用print()方法即可，因为print()方法是在父类中定义的，所以可以直接调用此方法。</p>
      <p>但是，现在要求，不同的图形类型在打印输出之前先输出相应的语句，例如： TetrominoT对象调用print()方法后，增加输出“I am a T”，TetrominoJ对象调用print()方法后，增加输出“I am a J”。因为现在print()方法是在父类中定义的，只有一个版本，无论是T类对象还是J类对象调用，都将输出相同的数据，所以现在无法针对对象的不同而输出不同的结果。若想实现此需求，需要介绍一个概念，叫做方法的重写。</p>
      <p>在java语言中，子类可以重写（覆盖）继承自父类的方法，即方法名和参数列表与父类的方法相同，但是方法的实现不同。</p>
      <p>当子类重写了父类的方法后，该重写方法被调用时（无论是通过子类的引用调用还是通过父类的引用调用），运行的都是子类重写后的版本。看如下的示例：</p>
      <div class="snippet-container" style="undefined;"><div class="sh_acid snippet-wrap"><div class="snippet-menu sh_sourceCode" style="display:none;"><pre style="display: none;"><a class="snippet-copy sh_url" href="http://pdf7.tarena.com.cn/tts8_source/ttsPage/JAVA/JSD_V05/OOP/DAY04/SUPERDOC/01/index.html#" style="display: none;">copy</a><a class="snippet-text sh_url" href="http://pdf7.tarena.com.cn/tts8_source/ttsPage/JAVA/JSD_V05/OOP/DAY04/SUPERDOC/01/index.html#">text</a><a class="snippet-window sh_url" href="http://pdf7.tarena.com.cn/tts8_source/ttsPage/JAVA/JSD_V05/OOP/DAY04/SUPERDOC/01/index.html#">pop-up</a></pre></div><pre class="code sh_java snippet-formatted sh_sourceCode"><ol class="snippet-num"><li><span class="sh_keyword">class</span><span class="sh_normal"> </span><span class="sh_classname">Foo</span> <span class="sh_cbracket">{</span></li><li>    <span class="sh_keyword">public</span> <span class="sh_type">void</span> <span class="sh_function">f</span><span class="sh_symbol">()</span> <span class="sh_cbracket">{</span></li><li>        System<span class="sh_symbol">.</span>out<span class="sh_symbol">.</span><span class="sh_function">println</span><span class="sh_symbol">(</span><span class="sh_string">"Foo.f()"</span><span class="sh_symbol">);</span></li><li>    <span class="sh_cbracket">}</span></li><li><span class="sh_cbracket">}</span></li><li><span class="sh_keyword">class</span><span class="sh_normal"> </span><span class="sh_classname">Goo</span> <span class="sh_keyword">extends</span> Foo <span class="sh_cbracket">{</span></li><li>    <span class="sh_keyword">public</span> <span class="sh_type">void</span> <span class="sh_function">f</span><span class="sh_symbol">()</span> <span class="sh_cbracket">{</span></li><li>        System<span class="sh_symbol">.</span>out<span class="sh_symbol">.</span><span class="sh_function">println</span><span class="sh_symbol">(</span><span class="sh_string">"Goo.f()"</span><span class="sh_symbol">);</span></li><li>    <span class="sh_cbracket">}</span></li><li><span class="sh_cbracket">}</span></li><li><span class="sh_keyword">class</span><span class="sh_normal"> </span><span class="sh_classname">Test</span><span class="sh_cbracket">{</span></li><li>&nbsp;&nbsp;&nbsp;&nbsp;<span class="sh_keyword">public</span> <span class="sh_keyword">static</span> <span class="sh_type">void</span> <span class="sh_function">main</span><span class="sh_symbol">(</span>String<span class="sh_symbol">[]</span> args<span class="sh_symbol">)</span><span class="sh_cbracket">{</span></li><li>    &nbsp;&nbsp;&nbsp;&nbsp;<span class="sh_usertype">Goo</span><span class="sh_normal"> </span>obj1 <span class="sh_symbol">=</span> <span class="sh_keyword">new</span> <span class="sh_function">Goo</span><span class="sh_symbol">();</span></li><li>obj1<span class="sh_symbol">.</span><span class="sh_function">f</span><span class="sh_symbol">();</span></li><li><span class="sh_usertype">Foo</span><span class="sh_normal"> </span>obj2 <span class="sh_symbol">=</span> <span class="sh_keyword">new</span> <span class="sh_function">Goo</span><span class="sh_symbol">();</span></li><li>obj2<span class="sh_symbol">.</span><span class="sh_function">f</span><span class="sh_symbol">();</span></li><li><span class="sh_cbracket">}</span></li><li><span class="sh_cbracket">}</span></li></ol></pre><pre class="snippet-textonly sh_sourceCode" style="display:none;">class Foo {
    public void f() {
        System.out.println("Foo.f()");
    }
}
class Goo extends Foo {
    public void f() {
        System.out.println("Goo.f()");
    }
}
class Test{
	public static void main(String[] args){
    	Goo obj1 = new Goo();
obj1.f();
Foo obj2 = new Goo();
obj2.f();
}
}
</pre></div></div>
      <p>分析代码得出结论：输出结果均为“Goo.f()”，因为都是Goo的对象，所以无论是子类的引用还是父类的引用，最终运行的都是子类重写后的版本。</p>
      <a name="Key01_01_02">
      </a>
      <h3>1.1.2. 重写中使用super关键字</h3>
      <p>在子类重写的方法中，可以通过super关键字调用父类的版本，参见如下的代码：</p>
      <div class="snippet-container" style="undefined;"><div class="sh_acid snippet-wrap"><div class="snippet-menu sh_sourceCode" style="display:none;"><pre style="display: none;"><a class="snippet-copy sh_url" href="http://pdf7.tarena.com.cn/tts8_source/ttsPage/JAVA/JSD_V05/OOP/DAY04/SUPERDOC/01/index.html#" style="display: none;">copy</a><a class="snippet-text sh_url" href="http://pdf7.tarena.com.cn/tts8_source/ttsPage/JAVA/JSD_V05/OOP/DAY04/SUPERDOC/01/index.html#">text</a><a class="snippet-window sh_url" href="http://pdf7.tarena.com.cn/tts8_source/ttsPage/JAVA/JSD_V05/OOP/DAY04/SUPERDOC/01/index.html#">pop-up</a></pre></div><pre class="code sh_java snippet-formatted sh_sourceCode"><ol class="snippet-num"><li><span class="sh_keyword">class</span><span class="sh_normal"> </span><span class="sh_classname">Foo</span> <span class="sh_cbracket">{</span></li><li>    <span class="sh_keyword">public</span> <span class="sh_type">void</span> <span class="sh_function">f</span><span class="sh_symbol">()</span> <span class="sh_cbracket">{</span></li><li>        System<span class="sh_symbol">.</span>out<span class="sh_symbol">.</span><span class="sh_function">println</span><span class="sh_symbol">(</span><span class="sh_string">"Foo.f()"</span><span class="sh_symbol">);</span></li><li>    <span class="sh_cbracket">}</span></li><li><span class="sh_cbracket">}</span></li><li><span class="sh_keyword">class</span><span class="sh_normal"> </span><span class="sh_classname">Goo</span> <span class="sh_keyword">extends</span> Foo <span class="sh_cbracket">{</span></li><li>    <span class="sh_keyword">public</span> <span class="sh_type">void</span> <span class="sh_function">f</span><span class="sh_symbol">()</span> <span class="sh_cbracket">{</span></li><li>        <span class="sh_keyword">super</span><span class="sh_symbol">.</span><span class="sh_function">f</span><span class="sh_symbol">();</span></li><li>        System<span class="sh_symbol">.</span>out<span class="sh_symbol">.</span><span class="sh_function">println</span><span class="sh_symbol">(</span><span class="sh_string">"Goo.f()"</span><span class="sh_symbol">);</span></li><li>    <span class="sh_cbracket">}</span></li><li><span class="sh_cbracket">}</span></li><li><span class="sh_keyword">class</span><span class="sh_normal"> </span><span class="sh_classname">Test</span><span class="sh_cbracket">{</span></li><li>&nbsp;&nbsp;&nbsp;&nbsp;<span class="sh_keyword">public</span> <span class="sh_keyword">static</span> <span class="sh_type">void</span> <span class="sh_function">main</span><span class="sh_symbol">(</span>String<span class="sh_symbol">[]</span> args<span class="sh_symbol">)</span><span class="sh_cbracket">{</span></li><li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="sh_usertype">Foo</span><span class="sh_normal"> </span>obj2 <span class="sh_symbol">=</span> <span class="sh_keyword">new</span> <span class="sh_function">Goo</span><span class="sh_symbol">();</span></li><li>obj2<span class="sh_symbol">.</span><span class="sh_function">f</span><span class="sh_symbol">();</span></li><li>    <span class="sh_cbracket">}</span></li><li><span class="sh_cbracket">}</span></li></ol></pre><pre class="snippet-textonly sh_sourceCode" style="display:none;">class Foo {
    public void f() {
        System.out.println("Foo.f()");
    }
}
class Goo extends Foo {
    public void f() {
        super.f();
        System.out.println("Goo.f()");
    }
}
class Test{
	public static void main(String[] args){
		Foo obj2 = new Goo();
obj2.f();
    }
}
</pre></div></div>
      <p>上面的代码中，super.f()即可以调用父类Foo的f()方法，此程序输出结果为：Foo.f() Goo.f()。这样的语法通常用于子类的重写方法在父类方法的基础之上进行的功能扩展。</p>
      <a name="Key01_01_03">
      </a>
      <h3>1.1.3. 重写和重载的区别</h3>
      <p>重载与重写是完全不同的语法现象，区别如下所示：</p>
      <ul class="list">
        <li>重载： 是指在一个类中定义多个方法名相同但参数列表不同的方法，在编译时，根据参数的个数和类型来决定绑定哪个方法。
</li>
        <li>重写： 是指在子类中定义和父类完全相同的方法，在程序运行时，根据对象的类型（而不是引用类型）而调用不同的方法。
</li>
      </ul>
      <p>分析如下代码的输出结果：</p>
      <div class="snippet-container" style="undefined;"><div class="sh_acid snippet-wrap"><div class="snippet-menu sh_sourceCode" style="display:none;"><pre style="display: none;"><a class="snippet-copy sh_url" href="http://pdf7.tarena.com.cn/tts8_source/ttsPage/JAVA/JSD_V05/OOP/DAY04/SUPERDOC/01/index.html#" style="display: none;">copy</a><a class="snippet-text sh_url" href="http://pdf7.tarena.com.cn/tts8_source/ttsPage/JAVA/JSD_V05/OOP/DAY04/SUPERDOC/01/index.html#">text</a><a class="snippet-window sh_url" href="http://pdf7.tarena.com.cn/tts8_source/ttsPage/JAVA/JSD_V05/OOP/DAY04/SUPERDOC/01/index.html#">pop-up</a></pre></div><pre class="code sh_java snippet-formatted sh_sourceCode"><ol class="snippet-num"><li><span class="sh_keyword">class</span><span class="sh_normal"> </span><span class="sh_classname">Super</span> <span class="sh_cbracket">{</span></li><li><span class="sh_keyword">public</span> <span class="sh_type">void</span> <span class="sh_function">f</span><span class="sh_symbol">()</span> <span class="sh_cbracket">{</span></li><li>System<span class="sh_symbol">.</span>out<span class="sh_symbol">.</span><span class="sh_function">println</span> <span class="sh_symbol">(</span><span class="sh_string">"super.f()"</span><span class="sh_symbol">);</span></li><li>    <span class="sh_cbracket">}</span></li><li><span class="sh_cbracket">}</span></li><li><span class="sh_keyword">class</span><span class="sh_normal"> </span><span class="sh_classname">Sub</span> <span class="sh_keyword">extends</span> Super <span class="sh_cbracket">{</span></li><li><span class="sh_keyword">public</span> <span class="sh_type">void</span> <span class="sh_function">f</span><span class="sh_symbol">()</span> <span class="sh_cbracket">{</span></li><li>System<span class="sh_symbol">.</span>out<span class="sh_symbol">.</span><span class="sh_function">println</span> <span class="sh_symbol">(</span><span class="sh_string">"sub.f()"</span><span class="sh_symbol">);</span></li><li>    <span class="sh_cbracket">}</span></li><li><span class="sh_cbracket">}</span></li><li><span class="sh_keyword">class</span><span class="sh_normal"> </span><span class="sh_classname">Goo</span> <span class="sh_cbracket">{</span></li><li><span class="sh_keyword">public</span> <span class="sh_type">void</span> <span class="sh_function">g</span><span class="sh_symbol">(</span><span class="sh_usertype">Super</span><span class="sh_normal"> </span>obj<span class="sh_symbol">)</span> <span class="sh_cbracket">{</span> </li><li>System<span class="sh_symbol">.</span>out<span class="sh_symbol">.</span><span class="sh_function">println</span> <span class="sh_symbol">(</span><span class="sh_string">"g(Super)"</span><span class="sh_symbol">);</span>  </li><li>obj<span class="sh_symbol">.</span><span class="sh_function">f</span><span class="sh_symbol">();</span></li><li>    <span class="sh_cbracket">}</span></li><li><span class="sh_keyword">public</span> <span class="sh_type">void</span> <span class="sh_function">g</span><span class="sh_symbol">(</span><span class="sh_usertype">Sub</span><span class="sh_normal"> </span>obj<span class="sh_symbol">)</span> <span class="sh_cbracket">{</span></li><li>System<span class="sh_symbol">.</span>out<span class="sh_symbol">.</span><span class="sh_function">println</span> <span class="sh_symbol">(</span><span class="sh_string">"g(Sub) "</span><span class="sh_symbol">);</span> </li><li>obj<span class="sh_symbol">.</span><span class="sh_function">f</span><span class="sh_symbol">();</span></li><li>    <span class="sh_cbracket">}</span></li><li><span class="sh_cbracket">}</span></li><li><span class="sh_keyword">class</span><span class="sh_normal"> </span><span class="sh_classname">Test</span><span class="sh_cbracket">{</span></li><li>&nbsp;&nbsp;&nbsp;&nbsp;<span class="sh_keyword">public</span> <span class="sh_keyword">static</span> <span class="sh_type">void</span> <span class="sh_function">main</span><span class="sh_symbol">(</span>String<span class="sh_symbol">[]</span> args<span class="sh_symbol">)</span><span class="sh_cbracket">{</span></li><li>        <span class="sh_usertype">Super</span><span class="sh_normal"> </span>obj <span class="sh_symbol">=</span> <span class="sh_keyword">new</span> <span class="sh_function">Sub</span><span class="sh_symbol">();</span></li><li><span class="sh_usertype">Goo</span><span class="sh_normal"> </span>goo <span class="sh_symbol">=</span> <span class="sh_keyword">new</span> <span class="sh_function">Goo</span><span class="sh_symbol">();</span></li><li>goo<span class="sh_symbol">.</span><span class="sh_function">g</span><span class="sh_symbol">(</span>obj<span class="sh_symbol">);</span></li><li><span class="sh_cbracket">}</span></li><li><span class="sh_cbracket">}</span></li></ol></pre><pre class="snippet-textonly sh_sourceCode" style="display:none;">class Super {
public void f() {
System.out.println ("super.f()");
    }
}
class Sub extends Super {
public void f() {
System.out.println ("sub.f()");
    }
}
class Goo {
public void g(Super obj) { 
System.out.println ("g(Super)");  
obj.f();
    }
public void g(Sub obj) {
System.out.println ("g(Sub) "); 
obj.f();
    }
}
class Test{
	public static void main(String[] args){
        Super obj = new Sub();
Goo goo = new Goo();
goo.g(obj);
}
}
</pre></div></div>
      <p>分析如上代码，输出结果为：g(Super) sub.f()。</p>
      <p>首先，重载遵循所谓“编译期绑定”，即在编译时根据参数变量的类型判断应该调用哪个方法， 因为变量obj为Super类型引用， 所以，Goo的g(Super)被调用，先输出g(Super)。</p>
      <p>重写遵循所谓“运行期绑定”，即在运行的时候，根据引用变量所指向的实际对象的类型来调用方法，因为obj实际指向的是子类Sub的对象，因此，子类重写后的f方法被调用，即sub.f()。</p>
      <a name="Key02">
      </a>
      <h1>2. 访问控制</h1>
      <a name="Key02_01">
      </a>
      <h2>2.1. 包的概念</h2>
      <a name="Key02_01_01">
      </a>
      <h3>2.1.1. package语句</h3>
      <p>定义类时需要指定类的名称，但是如果仅仅将类名作为类的唯一标识，则不可避免的出现命名冲突问题，这会给组件复用以及团队间的合作造成很大的麻烦！因为原则上来说，类名是不可以重复的。</p>
      <p>在Java语言中，命名冲突问题是用包（package）的概念来解决的，也就是说，在定义一个类时，除了定义类的名称一般还要指定一个包的名称，定义包名的语法如下所示：</p>
      <div class="snippet-container" style="undefined;"><div class="sh_acid snippet-wrap"><div class="snippet-menu sh_sourceCode" style="display:none;"><pre style="display: none;"><a class="snippet-copy sh_url" href="http://pdf7.tarena.com.cn/tts8_source/ttsPage/JAVA/JSD_V05/OOP/DAY04/SUPERDOC/01/index.html#" style="display: none;">copy</a><a class="snippet-text sh_url" href="http://pdf7.tarena.com.cn/tts8_source/ttsPage/JAVA/JSD_V05/OOP/DAY04/SUPERDOC/01/index.html#">text</a><a class="snippet-window sh_url" href="http://pdf7.tarena.com.cn/tts8_source/ttsPage/JAVA/JSD_V05/OOP/DAY04/SUPERDOC/01/index.html#">pop-up</a></pre></div><pre class="code sh_java snippet-formatted sh_sourceCode"><ol class="snippet-num"><li><span class="sh_preproc">package</span> 包名；</li></ol></pre><pre class="snippet-textonly sh_sourceCode" style="display:none;">package 包名；
</pre></div></div>
      <p>需要注意的是，在定义包时，package语句必须写在Java源文件的最开始处，即在类定义之前，如下面的语句将为Point类指定包名为“test”：</p>
      <div class="snippet-container" style="undefined;"><div class="sh_acid snippet-wrap"><div class="snippet-menu sh_sourceCode" style="display:none;"><pre style="display: none;"><a class="snippet-copy sh_url" href="http://pdf7.tarena.com.cn/tts8_source/ttsPage/JAVA/JSD_V05/OOP/DAY04/SUPERDOC/01/index.html#" style="display: none;">copy</a><a class="snippet-text sh_url" href="http://pdf7.tarena.com.cn/tts8_source/ttsPage/JAVA/JSD_V05/OOP/DAY04/SUPERDOC/01/index.html#">text</a><a class="snippet-window sh_url" href="http://pdf7.tarena.com.cn/tts8_source/ttsPage/JAVA/JSD_V05/OOP/DAY04/SUPERDOC/01/index.html#">pop-up</a></pre></div><pre class="code sh_java snippet-formatted sh_sourceCode"><ol class="snippet-num"><li><span class="sh_preproc">package</span> test<span class="sh_symbol">;</span></li><li><span class="sh_keyword">class</span><span class="sh_normal"> </span><span class="sh_classname">Point</span><span class="sh_cbracket">{</span></li><li>    ……</li><li><span class="sh_cbracket">}</span></li></ol></pre><pre class="snippet-textonly sh_sourceCode" style="display:none;">package test;
class Point{
    ……
}
</pre></div></div>
      <p>一旦使用package指定了包名，则类的全称应该是“包名.类名”，如上语句的Point类的全称为test.Point。</p>
      <p>使用package即可以解决命名冲突问题，只要保证在同一个包中的类名不重复即可，而不同的包中可以定义相同的类名，例如：test1.Point和test2.Point是两个截然不同的名称，虽然类名相同，但包名不同，亦表示两个完全不同的类。</p>
      <p>在命名包名时，包名可以有层次结构，在一个包中可以包含另外一个包，可以按照如下的方法定义package语句:</p>
      <div class="snippet-container" style="undefined;"><div class="sh_acid snippet-wrap"><div class="snippet-menu sh_sourceCode" style="display:none;"><pre style="display: none;"><a class="snippet-copy sh_url" href="http://pdf7.tarena.com.cn/tts8_source/ttsPage/JAVA/JSD_V05/OOP/DAY04/SUPERDOC/01/index.html#" style="display: none;">copy</a><a class="snippet-text sh_url" href="http://pdf7.tarena.com.cn/tts8_source/ttsPage/JAVA/JSD_V05/OOP/DAY04/SUPERDOC/01/index.html#">text</a><a class="snippet-window sh_url" href="http://pdf7.tarena.com.cn/tts8_source/ttsPage/JAVA/JSD_V05/OOP/DAY04/SUPERDOC/01/index.html#">pop-up</a></pre></div><pre class="code sh_java snippet-formatted sh_sourceCode"><ol class="snippet-num"><li><span class="sh_preproc">package</span> 包名<span class="sh_number">1</span><span class="sh_symbol">.</span>包名<span class="sh_number">2</span>…包名n<span class="sh_symbol">;</span></li></ol></pre><pre class="snippet-textonly sh_sourceCode" style="display:none;">package 包名1.包名2…包名n;
</pre></div></div>
      <p>在实际应用中，包的命名常常是多层次的。因为如果各个公司或开发组织的程序员都随心所欲的命名包名的话，依然不能从根本上解决命名冲突的问题，依然不利于软件的复用。因此，在指定包名时应该按照一定的规范，例如：</p>
      <div class="snippet-container" style="undefined;"><div class="sh_acid snippet-wrap"><div class="snippet-menu sh_sourceCode" style="display:none;"><pre style="display: none;"><a class="snippet-copy sh_url" href="http://pdf7.tarena.com.cn/tts8_source/ttsPage/JAVA/JSD_V05/OOP/DAY04/SUPERDOC/01/index.html#" style="display: none;">copy</a><a class="snippet-text sh_url" href="http://pdf7.tarena.com.cn/tts8_source/ttsPage/JAVA/JSD_V05/OOP/DAY04/SUPERDOC/01/index.html#">text</a><a class="snippet-window sh_url" href="http://pdf7.tarena.com.cn/tts8_source/ttsPage/JAVA/JSD_V05/OOP/DAY04/SUPERDOC/01/index.html#">pop-up</a></pre></div><pre class="code sh_java snippet-formatted sh_sourceCode"><ol class="snippet-num"><li>org<span class="sh_symbol">.</span>apache<span class="sh_symbol">.</span>commons<span class="sh_symbol">.</span>lang<span class="sh_symbol">.</span>StringUtil</li></ol></pre><pre class="snippet-textonly sh_sourceCode" style="display:none;">org.apache.commons.lang.StringUtil
</pre></div></div>
      <p>如上类的定义可以分为4个部分，其中，StringUtil是类名，org.apache.commons.lang是多层包名，其含义如下：org.apache表示公司或组织的信息（是这个公司或组织域名的反写）；commons表示项目的名称信息；lang表示模块的名称信息。</p>
      <a name="Key02_01_02">
      </a>
      <h3>2.1.2. import语句</h3>
      <p>为了避免类的命名冲突问题，在声明类时指定了包名。这时，对该类的访问就需要使用如下所示的全称：</p>
      <div class="snippet-container" style="undefined;"><div class="sh_acid snippet-wrap"><div class="snippet-menu sh_sourceCode" style="display:none;"><pre style="display: none;"><a class="snippet-copy sh_url" href="http://pdf7.tarena.com.cn/tts8_source/ttsPage/JAVA/JSD_V05/OOP/DAY04/SUPERDOC/01/index.html#" style="display: none;">copy</a><a class="snippet-text sh_url" href="http://pdf7.tarena.com.cn/tts8_source/ttsPage/JAVA/JSD_V05/OOP/DAY04/SUPERDOC/01/index.html#">text</a><a class="snippet-window sh_url" href="http://pdf7.tarena.com.cn/tts8_source/ttsPage/JAVA/JSD_V05/OOP/DAY04/SUPERDOC/01/index.html#">pop-up</a></pre></div><pre class="code sh_java snippet-formatted sh_sourceCode"><ol class="snippet-num"><li>org<span class="sh_symbol">.</span>whatisjava<span class="sh_symbol">.</span>core<span class="sh_symbol">.</span><span class="sh_usertype">Point</span><span class="sh_normal"> </span>p <span class="sh_symbol">=</span> <span class="sh_keyword">new</span> org<span class="sh_symbol">.</span>whatisjava<span class="sh_symbol">.</span>core<span class="sh_symbol">.</span><span class="sh_function">Point</span><span class="sh_symbol">();</span></li></ol></pre><pre class="snippet-textonly sh_sourceCode" style="display:none;">org.whatisjava.core.Point p = new org.whatisjava.core.Point();
</pre></div></div>
      <p>可以看到，如上的书写方式过于繁琐，不便于书写。解决这个问题，可以通过import语句对类的全称进行声明，import语句的语法如下所示：</p>
      <div class="snippet-container" style="undefined;"><div class="sh_acid snippet-wrap"><div class="snippet-menu sh_sourceCode" style="display:none;"><pre style="display: none;"><a class="snippet-copy sh_url" href="http://pdf7.tarena.com.cn/tts8_source/ttsPage/JAVA/JSD_V05/OOP/DAY04/SUPERDOC/01/index.html#" style="display: none;">copy</a><a class="snippet-text sh_url" href="http://pdf7.tarena.com.cn/tts8_source/ttsPage/JAVA/JSD_V05/OOP/DAY04/SUPERDOC/01/index.html#">text</a><a class="snippet-window sh_url" href="http://pdf7.tarena.com.cn/tts8_source/ttsPage/JAVA/JSD_V05/OOP/DAY04/SUPERDOC/01/index.html#">pop-up</a></pre></div><pre class="code sh_java snippet-formatted sh_sourceCode"><ol class="snippet-num"><li><span class="sh_preproc">import</span> 类的全局限定名（即包名<span class="sh_symbol">+</span>类名）；</li></ol></pre><pre class="snippet-textonly sh_sourceCode" style="display:none;">import 类的全局限定名（即包名+类名）；
</pre></div></div>
      <p>如上的Point类可以使用如下的import语句进行声明：</p>
      <div class="snippet-container" style="undefined;"><div class="sh_acid snippet-wrap"><div class="snippet-menu sh_sourceCode" style="display:none;"><pre style="display: none;"><a class="snippet-copy sh_url" href="http://pdf7.tarena.com.cn/tts8_source/ttsPage/JAVA/JSD_V05/OOP/DAY04/SUPERDOC/01/index.html#" style="display: none;">copy</a><a class="snippet-text sh_url" href="http://pdf7.tarena.com.cn/tts8_source/ttsPage/JAVA/JSD_V05/OOP/DAY04/SUPERDOC/01/index.html#">text</a><a class="snippet-window sh_url" href="http://pdf7.tarena.com.cn/tts8_source/ttsPage/JAVA/JSD_V05/OOP/DAY04/SUPERDOC/01/index.html#">pop-up</a></pre></div><pre class="code sh_java snippet-formatted sh_sourceCode"><ol class="snippet-num"><li><span class="sh_preproc">import</span> org<span class="sh_symbol">.</span>whatisjava<span class="sh_symbol">.</span>core<span class="sh_symbol">.</span>Point<span class="sh_symbol">;</span></li></ol></pre><pre class="snippet-textonly sh_sourceCode" style="display:none;">import org.whatisjava.core.Point;
</pre></div></div>
      <p>通过import语句声明了类的全称后，该源文件中就可以使用如下的方式，直接使用类名来访问了：</p>
      <div class="snippet-container" style="undefined;"><div class="sh_acid snippet-wrap"><div class="snippet-menu sh_sourceCode" style="display:none;"><pre style="display: none;"><a class="snippet-copy sh_url" href="http://pdf7.tarena.com.cn/tts8_source/ttsPage/JAVA/JSD_V05/OOP/DAY04/SUPERDOC/01/index.html#" style="display: none;">copy</a><a class="snippet-text sh_url" href="http://pdf7.tarena.com.cn/tts8_source/ttsPage/JAVA/JSD_V05/OOP/DAY04/SUPERDOC/01/index.html#">text</a><a class="snippet-window sh_url" href="http://pdf7.tarena.com.cn/tts8_source/ttsPage/JAVA/JSD_V05/OOP/DAY04/SUPERDOC/01/index.html#">pop-up</a></pre></div><pre class="code sh_java snippet-formatted sh_sourceCode"><ol class="snippet-num"><li><span class="sh_preproc">package</span> org<span class="sh_symbol">.</span>whatisjava<span class="sh_symbol">.</span>core<span class="sh_symbol">;</span></li><li><span class="sh_preproc">import</span> org<span class="sh_symbol">.</span>whatisjava<span class="sh_symbol">.</span>core<span class="sh_symbol">.</span>Point<span class="sh_symbol">;</span></li><li><span class="sh_keyword">public</span> <span class="sh_keyword">class</span><span class="sh_normal"> </span><span class="sh_classname">Main</span> <span class="sh_cbracket">{</span></li><li>     <span class="sh_keyword">public</span> <span class="sh_keyword">static</span> <span class="sh_type">void</span> <span class="sh_function">main</span><span class="sh_symbol">(</span>String<span class="sh_symbol">[]</span> args<span class="sh_symbol">)</span> <span class="sh_cbracket">{</span></li><li>         <span class="sh_usertype">Point</span><span class="sh_normal"> </span>p <span class="sh_symbol">=</span> <span class="sh_keyword">new</span> <span class="sh_function">Point</span><span class="sh_symbol">(</span><span class="sh_number">100</span><span class="sh_symbol">,</span> <span class="sh_number">200</span><span class="sh_symbol">)</span>；</li><li>     <span class="sh_cbracket">}</span></li><li><span class="sh_cbracket">}</span></li></ol></pre><pre class="snippet-textonly sh_sourceCode" style="display:none;">package org.whatisjava.core;
import org.whatisjava.core.Point;
public class Main {
     public static void main(String[] args) {
         Point p = new Point(100, 200)；
     }
}
</pre></div></div>
      <p>有时，在import语句中也可以使用“*”符号，例如：</p>
      <div class="snippet-container" style="undefined;"><div class="sh_acid snippet-wrap"><div class="snippet-menu sh_sourceCode" style="display:none;"><pre style="display: none;"><a class="snippet-copy sh_url" href="http://pdf7.tarena.com.cn/tts8_source/ttsPage/JAVA/JSD_V05/OOP/DAY04/SUPERDOC/01/index.html#" style="display: none;">copy</a><a class="snippet-text sh_url" href="http://pdf7.tarena.com.cn/tts8_source/ttsPage/JAVA/JSD_V05/OOP/DAY04/SUPERDOC/01/index.html#">text</a><a class="snippet-window sh_url" href="http://pdf7.tarena.com.cn/tts8_source/ttsPage/JAVA/JSD_V05/OOP/DAY04/SUPERDOC/01/index.html#">pop-up</a></pre></div><pre class="code sh_java snippet-formatted sh_sourceCode"><ol class="snippet-num"><li><span class="sh_preproc">import</span> org<span class="sh_symbol">.</span>whatisjava<span class="sh_symbol">.</span>core<span class="sh_symbol">.*</span>；</li></ol></pre><pre class="snippet-textonly sh_sourceCode" style="display:none;">import org.whatisjava.core.*；
</pre></div></div>
      <p>如上的import语句意味着声明该包中所有类的全称，即，在该源文件中，使用所有包名为org.whatisjava.core的类都可以仅仅通过类名来访问。在此需要注意的是，“import 包名.*”语句并不包含该名的子包中的类（org.whatisjava中的类不包含）。</p>
      <p>为了方便起见，在Eclipse中，可以使用“Ctrl+Shift+O”，自动完成import语句。</p>
      <a name="Key02_02">
      </a>
      <h2>2.2. 访问控制修饰符</h2>
      <a name="Key02_02_01">
      </a>
      <h3>2.2.1. 封装的意义</h3>
      <p>假设有水果店卖水果，分两种方式进行管理，方式一为需要店员，由店员实现取水果、包装、找零等功能。方式二为不需要店员，由顾客自行完成取水果、包装、找零等功能。那么想一想，哪一种方式更适合管理呢？一般认为方式一更适合，因为方式二没有人来进行管理，安全性较低，除非来的都是活雷锋，完全靠自觉。而方式一的安全性更高一些，并非任何人都可以操作水果。</p>
      <p>在软件系统中，常常通过封装来解决上面的问题。即：将容易变化的、具体的实现细节（卖水果）封装起来，外界不可访问，而对外提供可调用的、稳定的功能（店员），这样的意义在于：</p>
      <ol class="list">
        <li>降低代码出错的可能性，更便于维护。
</li>
        <li>当内部实现细节改变时，只要保证对外的功能定义不变，其他的模块不需要更改。
</li>
      </ol>
      <p>在软件系统中，封装常常需要依靠一些访问控制修饰符来实现。</p>
      <a name="Key02_02_02">
      </a>
      <h3>2.2.2. public和private</h3>
      <p>private与public为最最常用的两个访问控制修饰符，其中，private修饰的成员变量和方法仅仅只能在本类中调用，而public修饰的成员变量和方法可以在任何地方调用。</p>
      <p>private修饰的内容是对内实现的封装， 像刚刚案例中的水果， 就可以将它封装起来，因为，如果“公开”它将会增加维护的成本。public修饰的内容是对外提供的可以被调用的功能，需要相对稳定，相当于刚刚案例中的店员。</p>
      <p>public与private关键字的用法参见如下代码：</p>
      <div class="snippet-container" style="undefined;"><div class="sh_acid snippet-wrap"><div class="snippet-menu sh_sourceCode" style="display:none;"><pre style="display: none;"><a class="snippet-copy sh_url" href="http://pdf7.tarena.com.cn/tts8_source/ttsPage/JAVA/JSD_V05/OOP/DAY04/SUPERDOC/01/index.html#" style="display: none;">copy</a><a class="snippet-text sh_url" href="http://pdf7.tarena.com.cn/tts8_source/ttsPage/JAVA/JSD_V05/OOP/DAY04/SUPERDOC/01/index.html#">text</a><a class="snippet-window sh_url" href="http://pdf7.tarena.com.cn/tts8_source/ttsPage/JAVA/JSD_V05/OOP/DAY04/SUPERDOC/01/index.html#">pop-up</a></pre></div><pre class="code sh_java snippet-formatted sh_sourceCode"><ol class="snippet-num"><li><span class="sh_keyword">public</span> <span class="sh_keyword">class</span><span class="sh_normal"> </span><span class="sh_classname">Point</span> <span class="sh_cbracket">{</span></li><li>    <span class="sh_keyword">private</span> <span class="sh_type">int</span> x<span class="sh_symbol">;</span></li><li>    <span class="sh_keyword">private</span> <span class="sh_type">int</span> y<span class="sh_symbol">;</span></li><li>    <span class="sh_function">Point</span><span class="sh_symbol">(</span><span class="sh_type">int</span> x<span class="sh_symbol">,</span> <span class="sh_type">int</span> y<span class="sh_symbol">)</span> <span class="sh_cbracket">{</span>…<span class="sh_cbracket">}</span></li><li>    <span class="sh_keyword">public</span> <span class="sh_type">int</span> <span class="sh_function">distance</span><span class="sh_symbol">(</span><span class="sh_usertype">Point</span><span class="sh_normal"> </span>p<span class="sh_symbol">)</span> <span class="sh_cbracket">{</span>…<span class="sh_cbracket">}</span></li><li><span class="sh_cbracket">}</span></li><li><span class="sh_keyword">public</span> <span class="sh_keyword">class</span><span class="sh_normal"> </span><span class="sh_classname">Test</span><span class="sh_cbracket">{</span></li><li>Public <span class="sh_keyword">static</span> <span class="sh_type">void</span> <span class="sh_function">main</span><span class="sh_symbol">(</span>String<span class="sh_symbol">[]</span> args<span class="sh_symbol">)</span></li><li><span class="sh_cbracket">{</span></li><li><span class="sh_usertype">Point</span><span class="sh_normal"> </span>p1 <span class="sh_symbol">=</span> <span class="sh_keyword">new</span> <span class="sh_function">Point</span><span class="sh_symbol">(</span><span class="sh_number">1</span><span class="sh_symbol">,</span> <span class="sh_number">2</span><span class="sh_symbol">);</span></li><li><span class="sh_usertype">Point</span><span class="sh_normal"> </span>p2 <span class="sh_symbol">=</span> <span class="sh_keyword">new</span> <span class="sh_function">Point</span><span class="sh_symbol">(</span><span class="sh_number">3</span><span class="sh_symbol">,</span> <span class="sh_number">4</span><span class="sh_symbol">);</span></li><li>p1<span class="sh_symbol">.</span>x <span class="sh_symbol">=</span> <span class="sh_number">100</span></li><li><span class="sh_type">int</span> d <span class="sh_symbol">=</span> p1<span class="sh_symbol">.</span><span class="sh_function">distance</span><span class="sh_symbol">(</span>p2<span class="sh_symbol">);</span></li><li><span class="sh_cbracket">}</span></li><li><span class="sh_cbracket">}</span></li></ol></pre><pre class="snippet-textonly sh_sourceCode" style="display:none;">public class Point {
    private int x;
    private int y;
    Point(int x, int y) {…}
    public int distance(Point p) {…}
}
public class Test{
Public static void main(String[] args)
{
Point p1 = new Point(1, 2);
Point p2 = new Point(3, 4);
p1.x = 100
int d = p1.distance(p2);
}
}
</pre></div></div>
      <p>上面的代码中定义了Point类，类中包含两个private的成员变量，一个public的成员方法distance。在main方法中，声明Point类对象，对方法distance方法的访问执行正常，而通过p1.x = 100语句访问了Point类的x成员，此时将会出现错误。因为x定义为private的了，意味着只能在本类中访问，而现在是在另外一个类中，因此，是无法访问Point类的x成员的。</p>
      <a name="Key02_02_03">
      </a>
      <h3>2.2.3. protected和默认访问控制</h3>
      <p>protected和默认访问控制也是两种访问修饰。其中，使用protected修饰的成员变量和方法可以被子类及同一个包中的类使用。而默认访问控制即不书写任何访问控制符，默认访问控制的成员变量和方法可以被同一个包中的类调用。</p>
      <a name="Key02_02_04">
      </a>
      <h3>2.2.4. 访问控制符修饰类</h3>
      <p>对于类的修饰可以使用public和默认方式。 其中，public修饰的类可以被任何一个类使用，而默认访问控制的类只可以被同一个包中的类使用。</p>
      <p>而protected和private访问修饰符是不可以修饰类的，但其可以修饰内部类（后面课程详细介绍）。</p>
      <a name="Key02_02_05">
      </a>
      <h3>2.2.5. 访问控制符修饰成员</h3>
      <p>如上所介绍的4种访问修饰（public、private、protected、默认），都可以修饰成员，其权限如下图 – 1所示：</p>
      <div class="image">
        <img src="./SUPERDOC_files/image001.png">
        <p>图- 1</p>
      </div>
      <p>其中，public 修饰符，在任何地方都可以访问；protected可以在本类、同一包中的类、子类中访问，除此之外的其它类不可以访问；默认方式为可以本类及同一包中的类访问，除此之外其它类不可以访问；private只可以在本类中访问，其它任何类都不可以。</p>
      <a name="Key03">
      </a>
      <h1>3. static和final</h1>
      <a name="Key03_01">
      </a>
      <h2>3.1. static关键字</h2>
      <a name="Key03_01_01">
      </a>
      <h3>3.1.1. static修饰成员变量</h3>
      <p>static关键字可以修饰成员变量，它所修饰的成员变量不属于对象的数据结构，而是属于类的变量，通常通过类名来引用static成员。</p>
      <p>当创建对象后，成员变量是存储在堆中的，而static成员变量和类的信息一起存储在方法区, 而不是在堆中，</p>
      <p>一个类的static成员变量只有“一份”（存储在方法区），无论该类创建了多少对象。看如下的示例：</p>
      <div class="snippet-container" style="undefined;"><div class="sh_acid snippet-wrap"><div class="snippet-menu sh_sourceCode" style="display:none;"><pre style="display: none;"><a class="snippet-copy sh_url" href="http://pdf7.tarena.com.cn/tts8_source/ttsPage/JAVA/JSD_V05/OOP/DAY04/SUPERDOC/01/index.html#" style="display: none;">copy</a><a class="snippet-text sh_url" href="http://pdf7.tarena.com.cn/tts8_source/ttsPage/JAVA/JSD_V05/OOP/DAY04/SUPERDOC/01/index.html#">text</a><a class="snippet-window sh_url" href="http://pdf7.tarena.com.cn/tts8_source/ttsPage/JAVA/JSD_V05/OOP/DAY04/SUPERDOC/01/index.html#">pop-up</a></pre></div><pre class="code sh_java snippet-formatted sh_sourceCode"><ol class="snippet-num"><li><span class="sh_keyword">class</span><span class="sh_normal"> </span><span class="sh_classname">Cat</span> <span class="sh_cbracket">{</span></li><li>    <span class="sh_keyword">private</span> <span class="sh_type">int</span> age<span class="sh_symbol">;</span></li><li>    <span class="sh_keyword">private</span> <span class="sh_keyword">static</span> <span class="sh_type">int</span> numOfCats<span class="sh_symbol">;</span></li><li>    <span class="sh_keyword">public</span> <span class="sh_function">Cat</span><span class="sh_symbol">(</span><span class="sh_type">int</span> age<span class="sh_symbol">)</span> <span class="sh_cbracket">{</span></li><li>        <span class="sh_keyword">this</span><span class="sh_symbol">.</span>age <span class="sh_symbol">=</span> age<span class="sh_symbol">;</span></li><li>        System<span class="sh_symbol">.</span>out<span class="sh_symbol">.</span><span class="sh_function">println</span><span class="sh_symbol">(++</span>numOfCats<span class="sh_symbol">);</span></li><li>    <span class="sh_cbracket">}</span></li><li><span class="sh_cbracket">}</span></li></ol></pre><pre class="snippet-textonly sh_sourceCode" style="display:none;">class Cat {
    private int age;
    private static int numOfCats;
    public Cat(int age) {
        this.age = age;
        System.out.println(++numOfCats);
    }
}
</pre></div></div>
      <p>在main方法中声明两个Cat类对象：</p>
      <div class="snippet-container" style="undefined;"><div class="sh_acid snippet-wrap"><div class="snippet-menu sh_sourceCode" style="display:none;"><pre style="display: none;"><a class="snippet-copy sh_url" href="http://pdf7.tarena.com.cn/tts8_source/ttsPage/JAVA/JSD_V05/OOP/DAY04/SUPERDOC/01/index.html#" style="display: none;">copy</a><a class="snippet-text sh_url" href="http://pdf7.tarena.com.cn/tts8_source/ttsPage/JAVA/JSD_V05/OOP/DAY04/SUPERDOC/01/index.html#">text</a><a class="snippet-window sh_url" href="http://pdf7.tarena.com.cn/tts8_source/ttsPage/JAVA/JSD_V05/OOP/DAY04/SUPERDOC/01/index.html#">pop-up</a></pre></div><pre class="code sh_java snippet-formatted sh_sourceCode"><ol class="snippet-num"><li><span class="sh_usertype">Cat</span><span class="sh_normal"> </span>c1 <span class="sh_symbol">=</span> <span class="sh_keyword">new</span> <span class="sh_function">Cat</span><span class="sh_symbol">(</span> <span class="sh_number">2</span><span class="sh_symbol">);</span></li><li><span class="sh_usertype">Cat</span><span class="sh_normal"> </span>c2 <span class="sh_symbol">=</span> <span class="sh_keyword">new</span> <span class="sh_function">Cat</span><span class="sh_symbol">(</span> <span class="sh_number">3</span><span class="sh_symbol">);</span></li></ol></pre><pre class="snippet-textonly sh_sourceCode" style="display:none;">Cat c1 = new Cat( 2);
Cat c2 = new Cat( 3);
</pre></div></div>
      <p>其内存分配如下图-2所示：</p>
      <div class="image">
        <img src="./SUPERDOC_files/image002.png">
        <p>图- 2</p>
      </div>
      <p>如上的代码中，声明两个Cat类对象后，numOfCats的值为2。当声明第一个Cat类对象后，numOfCats值增1变为1，声明第二个Cat类对象后，因为numOfCats存在方法区中并且只有一份，所以其值在刚刚的1的基础之上变为2。</p>
      <a name="Key03_01_02">
      </a>
      <h3>3.1.2. static修饰方法</h3>
      <p>通常的方法都会涉及到对具体对象的操作，这些方法在调用时，需要隐式的传递对象的引用（this），如下代码所示，在调用distance方法时，除了传递p2参数外，还隐式的传递了p1作为参数，在方法中的this关键字即表示该参数：</p>
      <div class="snippet-container" style="undefined;"><div class="sh_acid snippet-wrap"><div class="snippet-menu sh_sourceCode" style="display:none;"><pre style="display: none;"><a class="snippet-copy sh_url" href="http://pdf7.tarena.com.cn/tts8_source/ttsPage/JAVA/JSD_V05/OOP/DAY04/SUPERDOC/01/index.html#" style="display: none;">copy</a><a class="snippet-text sh_url" href="http://pdf7.tarena.com.cn/tts8_source/ttsPage/JAVA/JSD_V05/OOP/DAY04/SUPERDOC/01/index.html#">text</a><a class="snippet-window sh_url" href="http://pdf7.tarena.com.cn/tts8_source/ttsPage/JAVA/JSD_V05/OOP/DAY04/SUPERDOC/01/index.html#">pop-up</a></pre></div><pre class="code sh_java snippet-formatted sh_sourceCode"><ol class="snippet-num"><li><span class="sh_type">int</span> d <span class="sh_symbol">=</span> p1<span class="sh_symbol">.</span><span class="sh_function">distance</span><span class="sh_symbol">(</span>p2<span class="sh_symbol">);</span></li></ol></pre><pre class="snippet-textonly sh_sourceCode" style="display:none;">int d = p1.distance(p2);
</pre></div></div>
      <p>而static修饰的方法则不需要针对某些对象进行操作，其运行结果仅仅与输入的参数有关，调用时直接用类名引用即可，如下代码所示：</p>
      <div class="snippet-container" style="undefined;"><div class="sh_acid snippet-wrap"><div class="snippet-menu sh_sourceCode" style="display:none;"><pre style="display: none;"><a class="snippet-copy sh_url" href="http://pdf7.tarena.com.cn/tts8_source/ttsPage/JAVA/JSD_V05/OOP/DAY04/SUPERDOC/01/index.html#" style="display: none;">copy</a><a class="snippet-text sh_url" href="http://pdf7.tarena.com.cn/tts8_source/ttsPage/JAVA/JSD_V05/OOP/DAY04/SUPERDOC/01/index.html#">text</a><a class="snippet-window sh_url" href="http://pdf7.tarena.com.cn/tts8_source/ttsPage/JAVA/JSD_V05/OOP/DAY04/SUPERDOC/01/index.html#">pop-up</a></pre></div><pre class="code sh_java snippet-formatted sh_sourceCode"><ol class="snippet-num"><li><span class="sh_type">double</span> c <span class="sh_symbol">=</span> Math<span class="sh_symbol">.</span><span class="sh_function">sqrt</span><span class="sh_symbol">(</span><span class="sh_number">3.0</span> <span class="sh_symbol">*</span> <span class="sh_number">3.0</span> <span class="sh_symbol">+</span> <span class="sh_number">4.0</span> <span class="sh_symbol">*</span> <span class="sh_number">4.0</span><span class="sh_symbol">);</span></li></ol></pre><pre class="snippet-textonly sh_sourceCode" style="display:none;">double c = Math.sqrt(3.0 * 3.0 + 4.0 * 4.0);
</pre></div></div>
      <p>上面的方法在调用时，没有隐式的传递对象引用，因此在static方法中是不可以使用this关键字的。另外，由于static在调用时没有具体的对象，因此在static方法中不能对非static成员（对象成员）进行访问。</p>
      <p>static方法的作用在于提供一些“工具方法”和“工厂方法”（后面课程详细介绍）等。像如下的一些工具方法，只是完成某一功能，不需要传递this：</p>
      <div class="snippet-container" style="undefined;"><div class="sh_acid snippet-wrap"><div class="snippet-menu sh_sourceCode" style="display:none;"><pre style="display: none;"><a class="snippet-copy sh_url" href="http://pdf7.tarena.com.cn/tts8_source/ttsPage/JAVA/JSD_V05/OOP/DAY04/SUPERDOC/01/index.html#" style="display: none;">copy</a><a class="snippet-text sh_url" href="http://pdf7.tarena.com.cn/tts8_source/ttsPage/JAVA/JSD_V05/OOP/DAY04/SUPERDOC/01/index.html#">text</a><a class="snippet-window sh_url" href="http://pdf7.tarena.com.cn/tts8_source/ttsPage/JAVA/JSD_V05/OOP/DAY04/SUPERDOC/01/index.html#">pop-up</a></pre></div><pre class="code sh_java snippet-formatted sh_sourceCode"><ol class="snippet-num"><li>Point<span class="sh_symbol">.</span><span class="sh_function">distance</span><span class="sh_symbol">(</span><span class="sh_usertype">Point</span><span class="sh_normal"> </span>p1<span class="sh_symbol">,</span> <span class="sh_usertype">Point</span><span class="sh_normal"> </span>p2<span class="sh_symbol">)</span></li><li>RandomUtils<span class="sh_symbol">.</span><span class="sh_function">nextInt</span><span class="sh_symbol">()</span></li><li>StringUtils<span class="sh_symbol">.</span><span class="sh_function">leftPad</span><span class="sh_symbol">(</span><span class="sh_usertype">String</span><span class="sh_normal"> </span>str<span class="sh_symbol">,</span>  <span class="sh_type">int</span> size<span class="sh_symbol">,</span>  <span class="sh_type">char</span> padChar<span class="sh_symbol">);</span></li><li>Math<span class="sh_symbol">.</span><span class="sh_function">sqrt</span><span class="sh_symbol">()</span>   Math<span class="sh_symbol">.</span><span class="sh_function">sin</span><span class="sh_symbol">()</span>   Arrays<span class="sh_symbol">.</span><span class="sh_function">sort</span><span class="sh_symbol">()</span></li></ol></pre><pre class="snippet-textonly sh_sourceCode" style="display:none;">Point.distance(Point p1, Point p2)
RandomUtils.nextInt()
StringUtils.leftPad(String str,  int size,  char padChar);
Math.sqrt()   Math.sin()   Arrays.sort()
</pre></div></div>
      <a name="Key03_01_03">
      </a>
      <h3>3.1.3. static块</h3>
      <p>static块为属于类的代码块，在类加载期间执行的代码块，只执行一次，可以用来在软件中加载静态资源（图像、音频等等）。如下代码演示了static块的执行：</p>
      <div class="snippet-container" style="undefined;"><div class="sh_acid snippet-wrap"><div class="snippet-menu sh_sourceCode" style="display:none;"><pre style="display: none;"><a class="snippet-copy sh_url" href="http://pdf7.tarena.com.cn/tts8_source/ttsPage/JAVA/JSD_V05/OOP/DAY04/SUPERDOC/01/index.html#" style="display: none;">copy</a><a class="snippet-text sh_url" href="http://pdf7.tarena.com.cn/tts8_source/ttsPage/JAVA/JSD_V05/OOP/DAY04/SUPERDOC/01/index.html#">text</a><a class="snippet-window sh_url" href="http://pdf7.tarena.com.cn/tts8_source/ttsPage/JAVA/JSD_V05/OOP/DAY04/SUPERDOC/01/index.html#">pop-up</a></pre></div><pre class="code sh_java snippet-formatted sh_sourceCode"><ol class="snippet-num"><li><span class="sh_keyword">class</span><span class="sh_normal"> </span><span class="sh_classname">Foo</span> <span class="sh_cbracket">{</span></li><li>   <span class="sh_keyword">static</span> <span class="sh_cbracket">{</span> </li><li>       <span class="sh_comment">//类加载期间，只执行一次</span></li><li>       System<span class="sh_symbol">.</span>out<span class="sh_symbol">.</span><span class="sh_function">println</span><span class="sh_symbol">(</span><span class="sh_string">" Load  Foo.class "</span><span class="sh_symbol">);</span></li><li>   <span class="sh_cbracket">}</span></li><li>   <span class="sh_keyword">public</span> <span class="sh_function">Foo</span><span class="sh_symbol">()</span> <span class="sh_cbracket">{</span></li><li>       System<span class="sh_symbol">.</span>out<span class="sh_symbol">.</span><span class="sh_function">println</span><span class="sh_symbol">(</span><span class="sh_string">"Foo()"</span><span class="sh_symbol">);</span></li><li>   <span class="sh_cbracket">}</span></li><li><span class="sh_cbracket">}</span></li><li><span class="sh_keyword">class</span><span class="sh_normal"> </span><span class="sh_classname">Test</span><span class="sh_cbracket">{</span></li><li>&nbsp;&nbsp;&nbsp;&nbsp;<span class="sh_keyword">public</span> <span class="sh_keyword">static</span> <span class="sh_type">void</span> <span class="sh_function">main</span><span class="sh_symbol">(</span>String<span class="sh_symbol">[]</span> args<span class="sh_symbol">)</span><span class="sh_cbracket">{</span></li><li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="sh_usertype">Foo</span><span class="sh_normal">  </span>foo <span class="sh_symbol">=</span> <span class="sh_keyword">new</span> <span class="sh_function">Foo</span><span class="sh_symbol">();</span></li><li><span class="sh_cbracket">}</span></li><li><span class="sh_cbracket">}</span></li></ol></pre><pre class="snippet-textonly sh_sourceCode" style="display:none;">class Foo {
   static { 
       //类加载期间，只执行一次
       System.out.println(" Load  Foo.class ");
   }
   public Foo() {
       System.out.println("Foo()");
   }
}
class Test{
	public static void main(String[] args){
		Foo  foo = new Foo();
}
}
</pre></div></div>
      <p>上面代码的输出结果为：</p>
      <ul class="list">
        <li>Load Foo.class
</li>
        <li>Foo();
</li>
      </ul>
      <p>因为，在Foo类加载时，先运行了静态块，而后执行了构造方法，即，static块是在创建对象之前执行的。</p>
      <a name="Key03_02">
      </a>
      <h2>3.2. final关键字</h2>
      <a name="Key03_02_01">
      </a>
      <h3>3.2.1. final修饰变量</h3>
      <p>final关键字修饰变量，意为不可改变。final可以修饰成员变量，也可以修饰局部变量，当final修饰成员变量时，可以有两种初始化方式：</p>
      <ol class="list">
        <li>声明同时初始化
</li>
        <li>构造函数中初始化
</li>
      </ol>
      <p>final关键字修饰局部变量，在使用之前初始化即可。参见如下示例：</p>
      <div class="snippet-container" style="undefined;"><div class="sh_acid snippet-wrap"><div class="snippet-menu sh_sourceCode" style="display:none;"><pre style="display: none;"><a class="snippet-copy sh_url" href="http://pdf7.tarena.com.cn/tts8_source/ttsPage/JAVA/JSD_V05/OOP/DAY04/SUPERDOC/01/index.html#" style="display: none;">copy</a><a class="snippet-text sh_url" href="http://pdf7.tarena.com.cn/tts8_source/ttsPage/JAVA/JSD_V05/OOP/DAY04/SUPERDOC/01/index.html#">text</a><a class="snippet-window sh_url" href="http://pdf7.tarena.com.cn/tts8_source/ttsPage/JAVA/JSD_V05/OOP/DAY04/SUPERDOC/01/index.html#">pop-up</a></pre></div><pre class="code sh_java snippet-formatted sh_sourceCode"><ol class="snippet-num"><li><span class="sh_keyword">public</span> <span class="sh_keyword">class</span><span class="sh_normal"> </span><span class="sh_classname">Emp</span> <span class="sh_cbracket">{</span></li><li>    <span class="sh_keyword">private</span> <span class="sh_keyword">final</span> <span class="sh_type">int</span> no <span class="sh_symbol">=</span> <span class="sh_number">100</span><span class="sh_symbol">;</span>  <span class="sh_comment">// final成员变量声明时初始化</span></li><li>    <span class="sh_keyword">public</span> <span class="sh_keyword">static</span> <span class="sh_type">void</span> <span class="sh_function">main</span><span class="sh_symbol">(</span>String<span class="sh_symbol">[]</span> args<span class="sh_symbol">)</span> <span class="sh_cbracket">{</span></li><li>         no <span class="sh_symbol">=</span> <span class="sh_number">99</span><span class="sh_symbol">;</span> </li><li>    <span class="sh_cbracket">}</span></li><li><span class="sh_cbracket">}</span></li></ol></pre><pre class="snippet-textonly sh_sourceCode" style="display:none;">public class Emp {
    private final int no = 100;  // final成员变量声明时初始化
    public static void main(String[] args) {
         no = 99; 
    }
}
</pre></div></div>
      <p>如上的语句，no=99会出现编译期错误，因为final的变量不可被改变。</p>
      <a name="Key03_02_02">
      </a>
      <h3>3.2.2. final修饰方法</h3>
      <p>final关键字修饰的方法不可以被重写。使一个方法不能被重写的意义在于：防止子类在定义新方法时造成的“不经意”重写。参见下面的代码：</p>
      <div class="snippet-container" style="undefined;"><div class="sh_acid snippet-wrap"><div class="snippet-menu sh_sourceCode" style="display:none;"><pre style="display: none;"><a class="snippet-copy sh_url" href="http://pdf7.tarena.com.cn/tts8_source/ttsPage/JAVA/JSD_V05/OOP/DAY04/SUPERDOC/01/index.html#" style="display: none;">copy</a><a class="snippet-text sh_url" href="http://pdf7.tarena.com.cn/tts8_source/ttsPage/JAVA/JSD_V05/OOP/DAY04/SUPERDOC/01/index.html#">text</a><a class="snippet-window sh_url" href="http://pdf7.tarena.com.cn/tts8_source/ttsPage/JAVA/JSD_V05/OOP/DAY04/SUPERDOC/01/index.html#">pop-up</a></pre></div><pre class="code sh_java snippet-formatted sh_sourceCode"><ol class="snippet-num"><li><span class="sh_keyword">public</span> <span class="sh_keyword">class</span><span class="sh_normal"> </span><span class="sh_classname">Car</span> <span class="sh_cbracket">{</span></li><li>   <span class="sh_comment">// 点火</span></li><li>   <span class="sh_keyword">public</span> <span class="sh_type">void</span> <span class="sh_function">fire</span><span class="sh_symbol">()</span> <span class="sh_cbracket">{</span>…<span class="sh_cbracket">}</span></li><li>   … … …</li><li><span class="sh_cbracket">}</span></li><li><span class="sh_keyword">public</span> <span class="sh_keyword">class</span><span class="sh_normal"> </span><span class="sh_classname">Tank</span> <span class="sh_keyword">extends</span> Car <span class="sh_cbracket">{</span></li><li>   <span class="sh_comment">// 开炮</span></li><li>   <span class="sh_keyword">public</span> <span class="sh_type">void</span> <span class="sh_function">fire</span><span class="sh_symbol">()</span> <span class="sh_cbracket">{</span>…<span class="sh_cbracket">}</span></li><li>   … … …</li><li><span class="sh_cbracket">}</span></li></ol></pre><pre class="snippet-textonly sh_sourceCode" style="display:none;">public class Car {
   // 点火
   public void fire() {…}
   … … …
}
public class Tank extends Car {
   // 开炮
   public void fire() {…}
   … … …
}
</pre></div></div>
      <p>上面的代码中，Car类有一个方法为fire（）点火，当点火后即汽车启动，坦克类Tank继承自Car类，重写了fire（）点火方法，而Tank类的点火即为开炮，而非坦克启动。此即Tank类误重写了Car类的fire（）方法。</p>
      <p>若想避免这种情况发生，可以将Car类的fire()方法声明为final的，那样该方法将不可以被子类重写了，如下代码所示：</p>
      <div class="snippet-container" style="undefined;"><div class="sh_acid snippet-wrap"><div class="snippet-menu sh_sourceCode" style="display:none;"><pre style="display: none;"><a class="snippet-copy sh_url" href="http://pdf7.tarena.com.cn/tts8_source/ttsPage/JAVA/JSD_V05/OOP/DAY04/SUPERDOC/01/index.html#" style="display: none;">copy</a><a class="snippet-text sh_url" href="http://pdf7.tarena.com.cn/tts8_source/ttsPage/JAVA/JSD_V05/OOP/DAY04/SUPERDOC/01/index.html#">text</a><a class="snippet-window sh_url" href="http://pdf7.tarena.com.cn/tts8_source/ttsPage/JAVA/JSD_V05/OOP/DAY04/SUPERDOC/01/index.html#">pop-up</a></pre></div><pre class="code sh_java snippet-formatted sh_sourceCode"><ol class="snippet-num"><li><span class="sh_keyword">public</span> <span class="sh_keyword">class</span><span class="sh_normal"> </span><span class="sh_classname">Car</span> <span class="sh_cbracket">{</span></li><li>   <span class="sh_comment">// 点火</span></li><li>   <span class="sh_keyword">public</span> <span class="sh_keyword">final</span> <span class="sh_type">void</span> <span class="sh_function">fire</span><span class="sh_symbol">()</span> <span class="sh_cbracket">{</span>…<span class="sh_cbracket">}</span></li><li>   … … …</li><li><span class="sh_cbracket">}</span></li></ol></pre><pre class="snippet-textonly sh_sourceCode" style="display:none;">public class Car {
   // 点火
   public final void fire() {…}
   … … …
}
</pre></div></div>
      <a name="Key03_02_03">
      </a>
      <h3>3.2.3. final修饰类</h3>
      <p>final关键字修饰的类不可以被继承。使一个类不能被继承的意义在于：可以保护类不被继承修改，可以控制滥用继承对系统造成的危害。在JDK中的一些基础类库被定义为final的，例如：String、Math、Integer、Double 等等。自己定义的类也可以声明为final的，如下代码所示：</p>
      <div class="snippet-container" style="undefined;"><div class="sh_acid snippet-wrap"><div class="snippet-menu sh_sourceCode" style="display:none;"><pre style="display: none;"><a class="snippet-copy sh_url" href="http://pdf7.tarena.com.cn/tts8_source/ttsPage/JAVA/JSD_V05/OOP/DAY04/SUPERDOC/01/index.html#" style="display: none;">copy</a><a class="snippet-text sh_url" href="http://pdf7.tarena.com.cn/tts8_source/ttsPage/JAVA/JSD_V05/OOP/DAY04/SUPERDOC/01/index.html#">text</a><a class="snippet-window sh_url" href="http://pdf7.tarena.com.cn/tts8_source/ttsPage/JAVA/JSD_V05/OOP/DAY04/SUPERDOC/01/index.html#">pop-up</a></pre></div><pre class="code sh_java snippet-formatted sh_sourceCode"><ol class="snippet-num"><li><span class="sh_keyword">final</span>  Foo <span class="sh_cbracket">{</span>  <span class="sh_cbracket">}</span></li><li><span class="sh_keyword">class</span><span class="sh_normal">  </span><span class="sh_classname">Goo</span>  <span class="sh_keyword">extends</span>  Foo <span class="sh_cbracket">{</span>   <span class="sh_cbracket">}</span> </li></ol></pre><pre class="snippet-textonly sh_sourceCode" style="display:none;">final  Foo {  }
class  Goo  extends  Foo {   } 
</pre></div></div>
      <p>上面的代码中，声明了final的Foo，而后Goo继承了Foo，此句会出现编译错误，因为final修饰的类不可以被继承。</p>
      <a name="Key03_02_04">
      </a>
      <h3>3.2.4. static final常量</h3>
      <p>static final 修饰的成员变量称为常量，必须声明同时初始化，并且不可被改变。常量建议所有字母大写。</p>
      <p>实际应用中应用率较广，因为static final常量是在编译期被替换的，可以节约不必要的开支，如下代码演示了static final的用法：</p>
      <div class="snippet-container" style="undefined;"><div class="sh_acid snippet-wrap"><div class="snippet-menu sh_sourceCode" style="display:none;"><pre style="display: none;"><a class="snippet-copy sh_url" href="http://pdf7.tarena.com.cn/tts8_source/ttsPage/JAVA/JSD_V05/OOP/DAY04/SUPERDOC/01/index.html#" style="display: none;">copy</a><a class="snippet-text sh_url" href="http://pdf7.tarena.com.cn/tts8_source/ttsPage/JAVA/JSD_V05/OOP/DAY04/SUPERDOC/01/index.html#">text</a><a class="snippet-window sh_url" href="http://pdf7.tarena.com.cn/tts8_source/ttsPage/JAVA/JSD_V05/OOP/DAY04/SUPERDOC/01/index.html#">pop-up</a></pre></div><pre class="code sh_java snippet-formatted sh_sourceCode"><ol class="snippet-num"><li><span class="sh_keyword">class</span><span class="sh_normal"> </span><span class="sh_classname">Foo</span> <span class="sh_cbracket">{</span></li><li>    <span class="sh_keyword">public</span> <span class="sh_keyword">static</span> <span class="sh_keyword">final</span> <span class="sh_type">int</span> NUM <span class="sh_symbol">=</span> <span class="sh_number">100</span><span class="sh_symbol">;</span></li><li><span class="sh_cbracket">}</span></li><li><span class="sh_keyword">class</span><span class="sh_normal"> </span><span class="sh_classname">Goo</span> <span class="sh_cbracket">{</span></li><li>    <span class="sh_keyword">public</span> <span class="sh_keyword">static</span> <span class="sh_type">void</span> <span class="sh_function">main</span><span class="sh_symbol">(</span>String<span class="sh_symbol">[]</span> args<span class="sh_symbol">)</span> <span class="sh_cbracket">{</span></li><li>        Sytem<span class="sh_symbol">.</span>out<span class="sh_symbol">.</span><span class="sh_function">println</span><span class="sh_symbol">(</span>Foo<span class="sh_symbol">.</span>NUM<span class="sh_symbol">);</span>  </li><li>        <span class="sh_comment">// 代码编译时，会替换为：System.out.println(100);</span></li><li>    <span class="sh_cbracket">}</span></li><li><span class="sh_cbracket">}</span></li></ol></pre><pre class="snippet-textonly sh_sourceCode" style="display:none;">class Foo {
    public static final int NUM = 100;
}
class Goo {
    public static void main(String[] args) {
        Sytem.out.println(Foo.NUM);  
        // 代码编译时，会替换为：System.out.println(100);
    }
}
</pre></div></div>
      <p>说明：static final常量Foo.NUM会在编译时被替换为其常量值（100），在运行Goo类时，Foo类不需要被载入。这样减少了不必要的开支。</p>
    </div>
  
<div style="position: static; width: 0px; height: 0px; border: none; padding: 0px; margin: 0px;"><div id="trans-tooltip"><div id="tip-left-top" style="background: url(&quot;chrome-extension://ikkepelhgbcgmhhmcmpfkjmchccjblkd/imgs/map/tip-left-top.png&quot;);"></div><div id="tip-top" style="background: url(&quot;chrome-extension://ikkepelhgbcgmhhmcmpfkjmchccjblkd/imgs/map/tip-top.png&quot;) repeat-x;"></div><div id="tip-right-top" style="background: url(&quot;chrome-extension://ikkepelhgbcgmhhmcmpfkjmchccjblkd/imgs/map/tip-right-top.png&quot;);"></div><div id="tip-right" style="background: url(&quot;chrome-extension://ikkepelhgbcgmhhmcmpfkjmchccjblkd/imgs/map/tip-right.png&quot;) repeat-y;"></div><div id="tip-right-bottom" style="background: url(&quot;chrome-extension://ikkepelhgbcgmhhmcmpfkjmchccjblkd/imgs/map/tip-right-bottom.png&quot;);"></div><div id="tip-bottom" style="background: url(&quot;chrome-extension://ikkepelhgbcgmhhmcmpfkjmchccjblkd/imgs/map/tip-bottom.png&quot;) repeat-x;"></div><div id="tip-left-bottom" style="background: url(&quot;chrome-extension://ikkepelhgbcgmhhmcmpfkjmchccjblkd/imgs/map/tip-left-bottom.png&quot;);"></div><div id="tip-left" style="background: url(&quot;chrome-extension://ikkepelhgbcgmhhmcmpfkjmchccjblkd/imgs/map/tip-left.png&quot;);"></div><div id="trans-content"></div></div><div id="tip-arrow-bottom" style="background: url(&quot;chrome-extension://ikkepelhgbcgmhhmcmpfkjmchccjblkd/imgs/map/tip-arrow-bottom.png&quot;);"></div><div id="tip-arrow-top" style="background: url(&quot;chrome-extension://ikkepelhgbcgmhhmcmpfkjmchccjblkd/imgs/map/tip-arrow-top.png&quot;);"></div></div></body></html>